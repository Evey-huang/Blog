---
title: TCP协议的三次握手和四次分手
date: 2018-11-08 18:10:49
tags: [TCP, 三次握手]
categories: Network
---

# 

![三次握手过程](https://ws4.sinaimg.cn/large/006tNbRwgy1fx0mhzeueqj30ob0r40ut.jpg)

## 三次握手

### 什么是三次握手

1. `第一次握手`：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后客户端进入`SYN_SEND`状态，等待服务器的确认。
2. `第二次握手`：服务器收到SYN报文段。服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入`SYN_RECV`状态；
3. `第三次握手`：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1（Sequence Number + 1），向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入`ESTABLISHED`状态，完成TCP三次握手。

### 为什么要进行三次握手

为了防止服务器一直等待而浪费资源

> 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据，这样会白白浪费server很多资源。

## 四次分手

### 什么是四次分手

1. `第一次分手`：主机1（客户端/服务器）设置Sequence Number和Acknowledgment Number向主机2发送一个FIN报文段，此时主机1进入`FIN_WAIT_1`状态，这表示主机1没有数据要发送给主机2了。
2. `第二次分手`：主机2收到主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number+1；主机1进入`FIN_WAIT_2`状态，这表示主机2告诉主机1“我同意你的关闭请求”。
3. `第三次分手`：主机2向向主机1发送FIN报文段，请求关闭连接，同时主机2进入`LAST_WAIT`状态。
4. `第四次分手`：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入`TIME_WAIT`状态；主机2收到主机1的ACK报文段以后，就关闭连接，此时主机1等待2MSL（最大报文段生存时间）后依然没有收到回复，则证明Server端已正常关闭，然后主机1也可以关闭连接了。

> ❓为什么当客户端进入TIME-WAIT状态的时候必须经过时间计数器设置的时间2MSL后才能进入CLOSED状态？
>
> A:
>
> 1. 为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
> 2. 他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。

### 为什么要进行四次分手

TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，

- 当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据。
- 当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；
- 当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

### 一些说明

- Sequence Number：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号；

- Acknowledgment Number：32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此确认序号应当是上次已成功收到数据字节序号加1（只有当标志位中的ACK=1时该确认序列号的字段才有效）；

- TCP Flags：TCP首部中有6个标志比特，主要用于操控TCP的状态机，依次为URG、ACK、PSH、RST、SYN、FIN。

  > ACK：表示应答域有效，为1时表示应答域有效，反之为0。
  >
  > SYN：表示同步序号，用来建立连接。
  >
  > - 当连接请求时，SYN=1，ACK=0
  > - 当连接被响应时，SYN=1，ACK=1
  >
  > FIN：表示发送端已经大道数据末尾，也就是双方的数据传送完成，没有数据可以传送了，发送FIN标志位的TCP数据包后，连接将被断开。

- FIN_WAIT_1：其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是`表示等待对方的FIN报文`。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。（主动方）

- FIN_WAIT_2：FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。（主动方）

- LAST_WAIT：它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）

- TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FINWAIT1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（主动方）

- CLOSED：表示连接中断